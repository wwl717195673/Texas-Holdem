# 德州扑克（Texas Hold'em）游戏规则手册

## 目录

1. [游戏概述](#1-游戏概述)
2. [扑克牌基础](#2-扑克牌基础)
3. [游戏流程](#3-游戏流程)
4. [下注规则](#4-下注规则)
5. [发牌逻辑](#5-发牌逻辑)
6. [手牌牌型](#6-手牌牌型)
7. [胜负判定](#7-胜负判定)
8. [特殊规则](#8-特殊规则)
9. [游戏状态机](#9-游戏状态机)
10. [数据结构设计](#10-数据结构设计)
11. [API接口设计](#11-api接口设计)

---

## 1. 游戏概述

### 1.1 游戏简介

德州扑克（Texas Hold'em）是世界上最流行的扑克游戏之一，通常由2-10名玩家参与。游戏使用一副标准52张扑克牌，每位玩家获得两张私有底牌（hole cards），然后通过五轮公共牌（community cards）的逐步揭示，最终由最好的五张牌组合决定胜负。

### 1.2 参与人数

- **标准人数**：2-10人
- **推荐人数**：6-9人（最佳游戏体验）
- **最少人数**：2人（可以进行，但策略会简化）

### 1.3 游戏目标

每位玩家的目标是利用自己手中的两张底牌与桌面上的五张公共牌，组合成最好的五张牌型，赢得底池（pot）中的筹码。

### 1.4 基础术语

- **底池（Pot）**：所有玩家在本局中下注的筹码总和
- **庄家（Dealer/Button）**：负责发牌的位置，标记为"D"
- **小盲注（Small Blind, SB）**：庄家左側玩家强制下注，通常是大盲注的一半
- **大盲注（Big Blind, BB）**：庄家左侧第二位玩家强制下注，是基础下注单位
- **翻牌（Flop）**：翻开的第三、第四、第五张公共牌
- **转牌（Turn）**：翻开的第六张公共牌
- **河牌（River）**：翻开的第七张（最后一张）公共牌
- **行动（Action）**：轮到某位玩家做出决定（下注、跟注、加注、弃牌等）

---

## 2. 扑克牌基础

### 2.1 牌组构成

一副标准德州扑克使用52张牌，不包含 Joker（鬼牌）。

#### 花色（Suits）

| 花色 | 英文名 | 符号 | 优先级（桥牌规则） |
|------|--------|------|-------------------|
| 黑桃 | Spades | ♠ | 最高 |
| 红心 | Hearts | ♥ | 第二 |
| 方块 | Diamonds | ♦ | 第三 |
| 梅花 | Clubs | ♣ | 最低 |

**注意**：在德州扑克的牌型比较中，**花色不参与大小比较**，只有在特定情况（如平分底池）时才会考虑花色。

#### 点数（Ranks）

| 点数 | 英文名 | 符号/简写 |
|------|--------|----------|
| Ace | A | A |
| King | K | K |
| Queen | Q | Q |
| Jack | J | J |
| 10 | Ten | 10 |
| 9 | Nine | 9 |
| 8 | Eight | 8 |
| 7 | Seven | 7 |
| 6 | Six | 6 |
| 5 | Five | 5 |
| 4 | Four | 4 |
| 3 | Three | 3 |
| 2 | Two | 2 |

### 2.2 牌的表示方法

在代码实现中，牌可以通过以下方式表示：

#### 方案一：位运算表示法（推荐）

```python
# 使用一个32位整数表示一张牌
# 位布局：[3][2][1][0] 价值位 | 花色位 | 点数位
# 0-3位：花色（0-3）
# 4-7位：点数（2-14，其中11=J, 12=Q, 13=K, 14=A）
# 8-31位：保留

def card_to_int(rank: int, suit: int) -> int:
    """将牌转换为整数表示"""
    return (rank << 4) | suit

def int_to_card(card_int: int) -> tuple:
    """将整数转换为牌"""
    rank = (card_int >> 4) & 0xF
    suit = card_int & 0xF
    return (rank, suit)
```

#### 方案二：对象表示法

```python
class Card:
    def __init__(self, rank: str, suit: str):
        self.rank = rank  # '2'-'10', 'J', 'Q', 'K', 'A'
        self.suit = suit  # '♠', '♥', '♦', '♣'
    
    def value(self) -> int:
        """获取牌的数值（2-14）"""
        rank_map = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, 
                   '7': 7, '8': 8, '9': 9, '10': 10,
                   'J': 11, 'Q': 12, 'K': 13, 'A': 14}
        return rank_map[self.rank]
```

#### 方案三：字符串编码

```python
# 使用两个字符的字符串
# 第一个字符：点数（2-9, T=10, J, Q, K, A）
# 第二个字符：花色（s=♠, h=♥, d=♦, c=♣）

# 示例：
# "As" = 黑桃A
# "Kh" = 红心K
# "7d" = 方块7

def parse_card(card_str: str) -> tuple:
    """解析牌字符串"""
    if len(card_str) == 3:  # 10开头的牌
        rank = card_str[:2]
        suit = card_str[2]
    else:
        rank = card_str[0]
        suit = card_str[1]
    return (rank, suit)
```

### 2.3 牌组初始化

```python
class Deck:
    RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
    SUITS = ['♠', '♥', '♦', '♣']
    
    def __init__(self):
        self.cards = [(rank, suit) for rank in self.RANKS for suit in self.SUITS]
        self.shuffle()
    
    def shuffle(self) -> None:
        """洗牌"""
        import random
        random.shuffle(self.cards)
    
    def deal(self, count: int = 1) -> list:
        """发牌"""
        if len(self.cards) < count:
            raise ValueError("牌组已用完")
        dealt = self.cards[:count]
        self.cards = self.cards[count:]
        return dealt
    
    def burn(self, count: int = 1) -> list:
        """弃牌（开局时丢弃第一张）"""
        return self.deal(count)
```

---

## 3. 游戏流程

### 3.1 单局游戏完整流程

德州扑克的一局游戏分为四个阶段：

```
开始 → 盲注阶段 → 发底牌 → 第一轮下注 → 翻牌 → 第二轮下注 → 转牌 → 第三轮下注 → 河牌 → 第四轮下注 → 摊牌 → 分配底池 → 结束
```

### 3.2 详细流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                      德州扑克游戏流程                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. 座位与庄家确定                                               │
│     ├── 随机选择庄家                                              │
│     └── 庄家按钮顺时针传递                                        │
│          │                                                       │
│  2. 盲注下注                                                     │
│     ├── 小盲位下注 SB                                            │
│     └── 大盲位下注 2×SB                                          │
│          │                                                       │
│  3. 发底牌（Pre-Flop）                                          │
│     ├── 弃牌一张（burn）                                         │
│     └── 依次发给每位玩家各两张（面对面为暗牌）                       │
│          │                                                       │
│  4. 第一轮下注（Pre-Flop Betting）                              │
│     ├── 从枪口位（UTG）开始                                       │
│     └── 按顺时针方向轮流行动                                       │
│          │                                                       │
│  5. 翻牌圈（Flop）                                               │
│     ├── 弃牌一张                                                 │
│     └── 发三张公共牌翻开                                          │
│          │                                                       │
│  6. 第二轮下注                                                   │
│     ├── 从庄家左侧第一位仍在游戏的玩家开始                          │
│     └── 按顺时针方向轮流行动                                       │
│          │                                                       │
│  7. 转牌圈（Turn）│
│     ├── 弃牌一张                                                 │
│     └── 发第四张公共牌翻开                                        │
│          │                                                       │
│  8. 第三轮下注                                                   │
│     └── 规则同第二轮                                              │
│          │                                                      │
│  9. 河牌圈（River）                                              │
│     ├── 弃牌一张                                                 │
│     └── 发第五张（最后一张）公共牌翻开                             │
│          │                                                      │
│  10. 第四轮下注                                                  │
│      └── 规则同第二轮                                             │
│           │                                                      │
│  11. 摊牌（Showdown）                                           │
│      ├── 未弃牌玩家亮出底牌                                       │
│      └── 比较牌型确定胜者                                         │
│           │                                                      │
│  12. 分配底池                                                    │
│      ├── 赢家赢得全部底池                                        │
│      └── 平分底池（如需要）                                       │
│           │                                                      │
│      结束                                                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 3.3 各阶段详细说明

#### 阶段1：座位与庄家确定

- 玩家随机抽取座位
- 随机选择庄家位置（标记为Button/D）
- 庄家位置在每局结束后顺时针传递

#### 阶段2：盲注下注（Blinds）

| 位置 | 相对于庄家 | 下注金额 | 说明 |
|------|-----------|---------|------|
| 小盲位（SB） | 庄家左侧 | 1x 单位 | 强制下注 |
| 大盲位（BB） | 庄家左侧第二位 | 2x 单位 | 强制下注 |

**示例**：
- 如果基础下注单位（Big Blind, BB）是100筹码
- 小盲位下注50
- 大盲位下注100

#### 阶段3：发底牌（Pre-Flop）

```
流程：
1. 庄家弃牌一张（burn）
2. 从庄家左侧开始，顺时针发牌
3. 每位玩家发一张底牌
4. 再发一张底牌
5. 现在每位玩家有2张私有底牌
```

**注意**：在线上游戏中，底牌只有玩家本人可见，其他玩家看到的是背面。

#### 阶段4-7：各轮下注

每轮下注的结构相同：
1. 公共牌翻开（翻牌/转牌/河牌阶段）
2. 第一位行动玩家开始下注
3. 玩家按顺时针方向轮流行动
4. 除非有加注，否则每人最多行动一次

#### 阶段8：摊牌（Showdown）

当所有下注结束后：
1. 从庄家方向开始，未弃牌玩家按顺序亮出底牌
2. 系统自动比较牌型
3. 最高牌型获胜
4. 如果平手，按以下规则分配底池：
   - 平分底池
   - 如果有多人获胜，每人获得底池的一部分

### 3.4 玩家行动顺序表

| 游戏阶段 | 起始玩家 | 说明 |
|---------|---------|------|
| 盲注 | 小盲位 → 大盲位 | 强制下注 |
| 翻牌前（Pre-Flop） | UTG（枪口位） | 庄家左侧第二位开始 |
| 翻牌圈（Flop） | SB位后第一位 | 庄家左侧第一位仍在游戏者 |
| 转牌圈（Turn） | SB位后第一位 | 同上 |
| 河牌圈（River） | SB位后第一位 | 同上 |

**UTG（Under the Gun）**：大盲注左侧第一位玩家，是翻牌前最后行动的玩家。

---

## 4. 下注规则

### 4.1 下注选项

每位玩家在自己的行动回合可以选择以下选项：

| 动作 | 英文 | 缩写 | 说明 |
|-----|------|-----|------|
| 弃牌 | Fold | - | 放弃本局，损失已下注筹码 |
| 看牌/过牌 | Check | - | 在无人下注时选择不下注 |
| 跟注 | Call | - | 下注与当前最高注额相同的筹码 |
| 加注 | Raise | - | 提高当前最高注额 |
| 全下 | All-in | - | 投入全部剩余筹码 |

### 4.2 下注规则详解

#### 4.2.1 弃牌（Fold）

- 玩家选择放弃本局
- 失去已投入的所有筹码
- 不再参与后续发牌和下注
- 不能再次进入本局游戏

**代码实现**：
```python
def fold(self) -> None:
    """玩家弃牌"""
    self.is_active = False
    self.has_folded = True
    self.status = PlayerStatus.FOLDED
```

#### 4.2.2 看牌（Check）

- 前提：当前没有下注（即注额为0）
- 玩家选择不下注，轮到下一位玩家
- 如果之前有人下注，不能看牌，只能跟注或加注

**代码实现**：
```python
def check(self) -> bool:
    """玩家看牌（仅当无人下注时）"""
    if self.game.current_bet > 0:
        raise InvalidActionError("不能看牌，必须跟注或加注")
    self.last_action = ActionType.CHECK
    return True
```

#### 4.2.3 跟注（Call）

- 前提：当前有人下注
- 玩家下注与当前最高注额相同的筹码
- 例如：当前最高注100，玩家已下50，则需再下50才能跟注

**代码实现**：
```python
def call(self) -> int:
    """玩家跟注，返回跟注金额"""
    amount_to_call = self.game.current_bet - self.current_bet
    if amount_to_call > self.chips:
        # 自动转为全下
        return self.all_in()
    self.chips -= amount_to_call
    self.current_bet += amount_to_call
    self.last_action = ActionType.CALL
    return amount_to_call
```

#### 4.2.4 加注（Raise）

- 玩家提高当前最高注额
- 加注额度必须至少等于前一次加注的额度（最小加注规则）
- 特殊规则：每次下注轮最多允许4次加注（4-bet cap），部分赌场无此限制

**最小加注规则**：
```
最小加注额 = 当前最高注额 × 2 - 玩家已下注额

示例：
- 当前最高注：100
- 玩家已下注：50
- 最小加注：100×2 - 50 = 150
- 即玩家需总共下200（50+150）
```

**代码实现**：
```python
def raise_(amount: int) -> int:
    """玩家加注"""
    min_raise = self.game.current_bet * 2 - self.current_bet
    
    if amount < min_raise:
        raise InvalidBetError(f"最小加注额为{min_raise}")
    
    if amount > self.chips:
        # 自动转为全下
        return self.all_in()
    
    self.chips -= amount
    self.current_bet += amount
    self.game.current_bet = self.current_bet
    self.last_action = ActionType.RAISE
    return amount
```

#### 4.2.5 全下（All-in）

- 玩家投入全部剩余筹码
- 不论金额大小，都视为有效下注
- 全下后，玩家仍可竞争底池（side pot机制）
- 全下玩家不能被强制弃牌

**代码实现**：
```python
def all_in(self) -> int:
    """玩家全下"""
    all_in_amount = self.chips
    self.current_bet += self.chips
    self.chips = 0
    self.is_all_in = True
    self.last_action = ActionType.ALL_IN
    
    # 更新当前最高注
    if self.current_bet > self.game.current_bet:
        self.game.current_bet = self.current_bet
    
    return all_in_amount
```

### 4.3 边池（Side Pot）机制

当有玩家全下时，会产生边池：

```
主池（Main Pot）：
- 所有玩家都可以竞争
- 金额 = 所有玩家的最小下注额

边池1（Side Pot 1）：
- 全下玩家不参与
- 金额 = 其他玩家额外下注

边池2（Side Pot 2）：
- 更大全下的玩家不参与
- 以此类推

示例：
- 玩家A：100筹码，全下
- 玩家B：300筹码，跟注100，剩余200
- 玩家C：500筹码，跟注100，剩余400，再加注100（总共200），剩余300
- 玩家D：弃牌

主池：400（每人100×4人）
边池1：600（B和C额外各300）
玩家A只能竞争主池
玩家B和C竞争主池+边池1
```

**代码实现**：
```python
def distribute_pots(self, winners: list) -> dict:
    """分配底池（包括主池和边池）"""
    pots = self.calculate_pots()
    distributions = {}
    
    for pot in pots:
        if len(pot.eligible_players) == 1:
            # 只有一人有资格，直接获得
            distributions[pot.eligible_players[0]] += pot.amount
        else:
            # 多人平分
            share = pot.amount // len(pot.eligible_players)
            remainder = pot.amount % len(pot.eligible_players)
            for player in pot.eligible_players:
                distributions[player] += share
            # 余数给第一位玩家（或其他规则）
            distributions[pot.eligible_players[0]] += remainder
        
        # 移除已分配的筹码
        self.pot -= pot.amount
    
    return distributions
```

### 4.4 下注轮结束条件

以下任一条件满足时，下注轮结束：

1. **所有玩家行动一致**：
   - 所有玩家都已跟注到相同注额，或
   - 所有玩家都已弃牌，或
   - 只剩一位玩家未弃牌

2. **特殊情况**：
   - 所有玩家都全下
   - 所有玩家都看牌（翻牌前不可能，因为有盲注）

### 4.5 下注结构示例

#### 4.5.1 固定限注（Limit Hold'em）

| 翻牌前/翻牌圈 | 转牌圈/河牌圈 |
|--------------|--------------|
| 1x 或 2x BB  | 2x BB        |

- 每轮下注固定为一定倍数
- 示例：$1/$2限注桌
  - 翻牌前/翻牌圈最大下注：$1
  - 转牌圈/河牌圈最大下注：$2

#### 4.5.2 底池限注（Pot-Limit）

- 任何下注或加注不能超过底池大小
- 最大加注 = 当前底池 + 当前最高注

```
计算方式：
最大加注 = 底池 + 跟注额 + 当前最高注

示例：
- 底池：100
- 当前最高注：50
- 跟注额：50
- 最大加注 = 100 + 50 + 50 = 200
```

#### 4.5.3 无限制（No-Limit）

- 任何下注可以从最小（1BB）到全部筹码
- 玩家可以随时全下
- 职业赛事中最常见的规则

### 4.6 行动决策超时

为防止玩家拖延游戏：

| 情况 | 超时时间 | 默认行动 |
|-----|---------|---------|
| 一般行动 | 30秒 | 无（需手动选择） |
| 全下/弃牌 | 15秒 | 弃牌 |
| 大额加注决策 | 60秒 | 无 |

---

## 5. 发牌逻辑

### 5.1 牌组管理

#### 5.1.1 牌组初始化

```python
class CardDeck:
    # 牌组常量
    NUM_CARDS = 52
    SUITS = ['♠', '♥', '♦', '♣']
    RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
    
    def __init__(self, num_decks: int = 1):
        """初始化牌组
        Args:
            num_decks: 使用的牌组数量（1-8）
        """
        self.num_decks = num_decks
        self.cards = self._create_deck()
        self.burned = []  # 已弃掉的牌
        self.dealt = []   # 已发出的牌
    
    def _create_deck(self) -> list:
        """创建牌组"""
        deck = []
        for _ in range(self.num_decks):
            for suit in self.SUITS:
                for rank in self.RANKS:
                    deck.append((rank, suit))
        return deck
    
    def shuffle(self, method: str = "fisher-yates") -> None:
        """洗牌
        Args:
            method: 洗牌算法（fisher-yates, riffle）
        """
        if method == "fisher-yates":
            self._fisher_yates_shuffle()
        elif method == "riffle":
            self._riffle_shuffle()
        random.shuffle(self.cards)
```

#### 5.1.2 洗牌算法

**Fisher-Yates洗牌（推荐）**：
```python
def _fisher_yates_shuffle(self) -> None:
    """Fisher-Yates洗牌算法 O(n)"""
    for i in range(len(self.cards) - 1, 0, -1):
        j = random.randint(0, i)
        self.cards[i], self.cards[j] = self.cards[j], self.cards[i]
```

**交叉洗牌（Riffle Shuffle）**：
```python
def _riffle_shuffle(self, times: int = 7) -> None:
    """交叉洗牌
    Args:
        times: 洗牌次数
    """
    for _ in range(times):
        mid = len(self.cards) // 2
        left = self.cards[:mid]
        right = self.cards[mid:]
        
        new_deck = []
        l_idx, r_idx = 0, 0
        
        while l_idx < len(left) or r_idx < len(right):
            if l_idx < len(left) and r_idx < len(right):
                if random.random() < 0.5:
                    new_deck.append(left[l_idx])
                    l_idx += 1
                else:
                    new_deck.append(right[r_idx])
                    r_idx += 1
            elif l_idx < len(left):
                new_deck.append(left[l_idx])
                l_idx += 1
            else:
                new_deck.append(right[r_idx])
                r_idx += 1
        
        self.cards = new_deck
```

### 5.2 发牌流程

#### 5.2.1 标准发牌流程

```
德州扑克发牌顺序：

┌──────────────────────────────────────────────────────────┐
│  阶段              │  弃牌  │  发牌  │  接收者              │
├──────────────────────────────────────────────────────────┤
│  盲注下注后        │  1张   │  --   │  --                  │
├──────────────────────────────────────────────────────────┤
│  第一张底牌        │  --    │  1张   │  SB → BB → ... → BTN │
├──────────────────────────────────────────────────────────┤
│  第二张底牌        │  --    │  1张   │  SB → BB → ... → BTN │
├──────────────────────────────────────────────────────────┤
│  翻牌（Flop）      │  1张   │  3张   │  公共牌              │
├──────────────────────────────────────────────────────────┤
│  转牌（Turn）      │  1张   │  1张   │  公共牌              │
├──────────────────────────────────────────────────────────┤
│  河牌（River）     │  1张   │  1张   │  公共牌              │
└──────────────────────────────────────────────────────────┘

总计：弃牌5张 + 底牌2张×玩家数 + 公共牌5张
```

#### 5.2.2 发牌代码实现

```python
class Dealer:
    def __init__(self, deck: CardDeck):
        self.deck = deck
        self.community_cards = []  # 公共牌
        self.burned_cards = []     # 已弃掉的牌
    
    def deal_hole_cards(self, players: list, cards_per_player: int = 2) -> dict:
        """发底牌
        Args:
            players: 玩家列表
            cards_per_player: 每位玩家发的牌数
        
        Returns:
            dict: {player_id: [cards]}
        """
        # 先弃牌一张
        self.burn_card()
        
        result = {}
        
        # 依次发牌
        for i in range(cards_per_player):
            for player in players:
                if player.is_active and not player.has_folded:
                    card = self.deck.deal(1)[0]
                    player.receive_hole_card(card)
                    result.setdefault(player.id, []).append(card)
        
        return result
    
    def deal_flop(self) -> list:
        """发翻牌（三张公共牌）"""
        # 弃牌一张
        self.burn_card()
        
        # 发三张公共牌
        self.community_cards = self.deck.deal(3)
        return self.community_cards
    
    def deal_turn(self) -> Card:
        """发转牌（第四张公共牌）"""
        # 弃牌一张
        self.burn_card()
        
        # 发一张公共牌
        card = self.deck.deal(1)[0]
        self.community_cards.append(card)
        return card
    
    def deal_river(self) -> Card:
        """发河牌（第五张公共牌）"""
        # 弃牌一张
        self.burn_card()
        
        # 发一张公共牌
        card = self.deck.deal(1)[0]
        self.community_cards.append(card)
        return card
    
    def burn_card(self) -> Card:
        """弃牌一张"""
        if len(self.deck.cards) > 0:
            card = self.deck.deal(1)[0]
            self.burned_cards.append(card)
            return card
        raise DeckEmptyError("牌组已用完")
```

### 5.3 发牌状态管理

```python
from enum import Enum, auto

class DealingStage(Enum):
    """发牌阶段"""
    PRE_Hole_CARDS = auto()      # 发底牌前
    DEALING_HOLE_CARDS = auto()   # 发底牌中
    HOLE_CARDS_COMPLETE = auto()  # 底牌发完
    PRE_FLOP = auto()             # 翻牌前下注
    PRE_FLOP_BETTING = auto()     # 翻牌前下注中
    FLOP_COMPLETE = auto()        # 翻牌发完
    TURN_COMPLETE = auto()        # 转牌发完
    RIVER_COMPLETE = auto()       # 河牌发完
    SHOWDOWN = auto()             # 摊牌
    GAME_END = auto()             # 游戏结束

class DealingManager:
    """发牌管理器"""
    
    def __init__(self):
        self.stage = DealingStage.PRE_HOLE_CARDS
        self.deck = CardDeck()
        self.dealer = Dealer(self.deck)
        self.community_cards = []  # 公共牌
        self.burned_cards = []     # 已弃牌
    
    def advance_stage(self) -> None:
        """推进发牌阶段"""
        stage_order = [
            DealingStage.PRE_HOLE_CARDS,
            DealingStage.HOLE_CARDS_COMPLETE,
            DealingStage.PRE_FLOP_BETTING,
            DealingStage.FLOP_COMPLETE,
            DealingStage.TURN_COMPLETE,
            DealingStage.RIVER_COMPLETE,
            DealingStage.SHOWDOWN,
            DealingStage.GAME_END
        ]
        
        current_index = stage_order.index(self.stage)
        if current_index < len(stage_order) - 1:
            self.stage = stage_order[current_index + 1]
    
    def reset_for_new_hand(self) -> None:
        """重置准备下一局"""
        self.deck = CardDeck()
        self.dealer = Dealer(self.deck)
        self.community_cards = []
        self.burned_cards = []
        self.stage = DealingStage.PRE_HOLE_CARDS
```

### 5.4 特殊发牌规则

#### 5.4.1 快速发牌模式

用于测试或快速游戏：
```python
def deal_fast(self, players: list) -> dict:
    """快速发牌（不弃牌，直接预计算）"""
    # 预计算所有需要的牌
    total_needed = (
        2 * len(players) +  # 底牌
        3 +                  # 翻牌
        1 +                  # 转牌
        1                    # 河牌
    )
    
    # 直接分配
    hole_cards = {}
    idx = 0
    
    for player in players:
        hole_cards[player.id] = self.deck.cards[idx:idx+2]
        idx += 2
    
    # 公共牌
    flop = self.deck.cards[idx:idx+3]
    idx += 3
    turn = self.deck.cards[idx]
    idx += 1
    river = self.deck.cards[idx]
    
    return {
        'hole_cards': hole_cards,
        'flop': flop,
        'turn': turn,
        'river': river
    }
```

#### 5.4.2 备用牌组

当一副牌不够时：
```python
class MultipleDeckManager:
    """多牌组管理器"""
    
    def __init__(self, num_decks: int = 1):
        self.active_deck = CardDeck(num_decks)
        self.backup_decks = []  # 备用牌组
    
    def switch_to_backup_deck(self) -> bool:
        """切换到备用牌组"""
        if self.backup_decks:
            self.active_deck = self.backup_decks.pop(0)
            return True
        return False
    
    def get_remaining_cards(self) -> int:
        """获取剩余牌数"""
        return len(self.active_deck.cards)
```

### 5.5 发牌验证

```python
class DealingValidator:
    """发牌验证器"""
    
    @staticmethod
    def validate_deck_integrity(deck: CardDeck) -> bool:
        """验证牌组完整性"""
        return len(deck.cards) == 52
    
    @staticmethod
    def validate_no_duplicate_cards(dealt_cards: list) -> bool:
        """验证无重复发牌"""
        return len(dealt_cards) == len(set(dealt_cards))
    
    @staticmethod
    def validate_enough_cards(players: list, stage: str) -> bool:
        """验证剩余牌数足够"""
        required = {
            'pre_flop': 2 * len(players),
            'flop': 3,
            'turn': 1,
            'river': 1
        }
        return deck.remaining_cards() >= required.get(stage, 0)
```

---

## 6. 手牌牌型

### 6.1 牌型等级（从高到低）

```
德州扑克牌型等级（皇家同花顺最大，高牌最小）：

┌─────────────────────────────────────────────────────────────────┐
│  等级  │  牌型名称            │  英文名              │  概率    │
├─────────────────────────────────────────────────────────────────┤
│   1   │  皇家同花顺          │  Royal Flush         │ 0.00015% │
│   2   │  同花顺              │  Straight Flush      │ 0.00139% │
│   3   │  四条                │  Four of a Kind      │ 0.02401% │
│   4   │  葫芦                │  Full House          │ 0.14407% │
│   5   │  同花                │  Flush               │ 0.19654% │
│   6   │  顺子                │  Straight            │ 0.39246% │
│   7   │  三条                │  Three of a Kind     │ 2.11285% │
│   8   │  两对                │  Two Pair            │ 4.75390% │
│   9   │  一对                │  One Pair            │ 42.2569% │
│  10   │  高牌                │  High Card           │ 50.1177% │
└─────────────────────────────────────────────────────────────────┘

概率基于随机7张牌的最佳5张组合计算
```

### 6.2 牌型详细说明

#### 6.2.1 皇家同花顺（Royal Flush）

```
定义：同一花色的A、K、Q、J、10

示例：
♠A ♠K ♠Q ♠J ♠10

特点：
- 德州扑克中最高牌型
- 无法被其他任何牌型击败
- 概率极低（约649,740分之一）
```

#### 6.2.2 同花顺（Straight Flush）

```
定义：同一花色的连续五张牌（不含皇家同花顺）

示例：
♥9 ♥8 ♥7 ♥6 ♥5

比较规则：
- 数字最大的牌决定大小
- A2345是最小的同花顺（5高顺子）
- 10JQKA是最大的同花顺（即皇家同花顺）

牌值比较（从大到小）：
AKQJT > QJT98 > 98765 > 5432A
```

#### 6.2.3 四条（Four of a Kind / Quads）

```
定义：四张相同点数的牌加任意一张其他牌

示例：
♠K ♥K ♦K ♣K ♠7

比较规则：
- 比较四条的点数值
- 四条相同则比较 kicker（第五张牌）

牌值比较：
KKKKA > KKKKQ > QQQQJ > 99992
```

#### 6.2.4 葫芦（Full House）

```
定义：三张相同点数的牌加一对相同点数的牌

示例：
♠Q ♥Q ♦Q ♣9 ♥9

比较规则：
- 先比较三条的点数值
- 条数相同则比较对子的点数值

牌值比较：
QQQ99 > QQQ88 > JJJAA > 999QQ
```

#### 6.2.5 同花（Flush）

```
定义：五张同一花色的牌（不连续）

示例：
♠K ♠9 ♠7 ♠5 ♠3

比较规则：
- 从最大牌开始比较
- 花色在比较中不占优势

牌值比较：
K9753 > K9642 > QJT95 > A7532
```

#### 6.2.6 顺子（Straight）

```
定义：五张连续点数的牌（花色不限）

示例：
♠9 ♥8 ♦7 ♣6 ♥5

特殊顺子：
- A2345（A可以作1）
- 10JQKA

比较规则：
- 数字最大的牌决定顺子大小
- A2345是最小的顺子（5高）
- 10JQKA是最大的顺子（A高）

牌值比较：
AKQJT > QJT98 > 98765 > 5432A
```

#### 6.2.7 三条（Three of a Kind / Set / Trips）

```
定义：三张相同点数的牌加两张不相关散牌

示例：
♠J ♥J ♦J ♣8 ♥4

比较规则：
- 先比较三条的点数值
- 然后比较大 kicker
- 最后比较小 kicker

牌值比较：
JJJ84 > JJJ63 > TTT97 > 999AQ
```

#### 6.2.8 两对（Two Pair）

```
定义：两组对子加一张散牌

示例：
♠K ♥K ♠9 ♦9 ♣4

比较规则：
- 先比较较大的对子
- 然后比较较小的对子
- 最后比较 kicker

牌值比较：
KK99Q > KK998 > JJ99A > 9977K
```

#### 6.2.9 一对（One Pair）

```
定义：一组对子加三张散牌

示例：
♠8 ♥8 ♦7 ♣4 ♠2

比较规则：
- 先比较对子的点数值
- 然后比较大 kicker
- 最后比较小 kicker

牌值比较：
88AKQ > 88AT9 > 77AKQ > 66JQ10
```

#### 6.2.10 高牌（High Card）

```
定义：无上述任何牌型时，最大五张散牌

示例：
♠A ♥K ♦9 ♣7 ♠3

比较规则：
- 从最大牌开始依次比较
- 五张牌全部参与比较

牌值比较：
AKQ93 > AKQ85 > AJT97 > KQJT9
```

### 6.3 牌型实现代码

```python
from typing import List, Tuple, Optional
from collections import Counter
from enum import Enum, auto

class HandRank(Enum):
    """手牌等级"""
    HIGH_CARD = 10
    ONE_PAIR = 9
    TWO_PAIR = 8
    THREE_OF_A_KIND = 7
    STRAIGHT = 6
    FLUSH = 5
    FULL_HOUSE = 4
    FOUR_OF_A_KIND = 3
    STRAIGHT_FLUSH = 2
    ROYAL_FLUSH = 1

class PokerHand:
    """德州扑克手牌"""
    
    # 点数值映射
    RANK_VALUES = {
        '2': 2, '3': 3, '4': 4, '5': 5, '6': 6,
        '7': 7, '8': 8, '9': 9, '10': 10,
        'J': 11, 'Q': 12, 'K': 13, 'A': 14
    }
    
    def __init__(self, hole_cards: List[Tuple], community_cards: List[Tuple]):
        """初始化手牌
        Args:
            hole_cards: 底牌 [(rank, suit), ...]
            community_cards: 公共牌 [(rank, suit), ...]
        """
        self.all_cards = hole_cards + community_cards
        self.hole_cards = hole_cards
        self.community_cards = community_cards
        self.best_hand = self._evaluate_best_hand()
    
    def _get_rank_values(self) -> List[int]:
        """获取所有牌的值列表"""
        return [self.RANK_VALUES[card[0]] for card in self.all_cards]
    
    def _get_suits(self) -> List[str]:
        """获取所有牌的花色列表"""
        return [card[1] for card in self.all_cards]
    
    def _evaluate_best_hand(self) -> Tuple[HandRank, List[int]]:
        """评估最佳五张牌组合
        Returns:
            (牌型等级, 辅助比较值列表)
        """
        ranks = self._get_rank_values()
        suits = self._get_suits()
        rank_counts = Counter(ranks)
        
        # 检查同花（需要5张同花）
        suit_groups = {}
        for rank, suit in zip(ranks, suits):
            suit_groups.setdefault(suit, []).append(rank)
        
        # 检查顺子
        unique_ranks = sorted(set(ranks))
        # A可以作1
        ranks_with_ace_low = unique_ranks.copy()
        if 14 in ranks_with_ace_low:
            ranks_with_ace_low.append(1)
        
        straight_high = self._check_straight(ranks_with_ace_low)
        
        # 1. 皇家同花顺
        if straight_high == 14 and len(suit_groups.get(max(suit_groups, 
              key=lambda s: max(suit_groups[s])), [])) >= 5:
            flush_cards = suit_groups[max(suit_groups, 
                            key=lambda s: max(suit_groups[s]))]
            if 14 in flush_cards and 13 in flush_cards and 12 in flush_cards and \
               11 in flush_cards and 10 in flush_cards:
                return (HandRank.ROYAL_FLUSH, [])
        
        # 2. 同花顺
        for suit, suit_ranks in suit_groups.items():
            straight_high_suit = self._check_straight(sorted(set(suit_ranks)) + 
                                                      ([1] if 14 in suit_ranks else []))
            if straight_high_suit:
                return (HandRank.STRAIGHT_FLUSH, [straight_high_suit])
        
        # 3. 四条
        for rank, count in rank_counts.most_common(4):
            if count == 4:
                kickers = sorted([r for r in ranks if r != rank], reverse=True)
                return (HandRank.FOUR_OF_A_KIND, [rank] + kickers[:1])
        
        # 4. 葫芦
        three_of_kind = [r for r, c in rank_counts.items() if c == 3]
        pairs = [r for r, c in rank_counts.items() if c == 2]
        if three_of_kind and (pairs or len(three_of_kind) >= 2):
            three = max(three_of_kind)
            remaining_pairs = [r for r in three_of_kind if r != three] + pairs
            if remaining_pairs:
                pair = max(remaining_pairs)
                return (HandRank.FULL_HOUSE, [three, pair])
        
        # 5. 同花
        for suit, suit_ranks in suit_groups.items():
            if len(suit_ranks) >= 5:
                sorted_flush = sorted(set(suit_ranks), reverse=True)[:5]
                return (HandRank.FLUSH, sorted_flush)
        
        # 6. 顺子
        if straight_high:
            return (HandRank.STRAIGHT, [straight_high])
        
        # 7. 三条
        for rank, count in rank_counts.most_common(4):
            if count == 3:
                kickers = sorted([r for r in ranks if r != rank], reverse=True)[:2]
                return (HandRank.THREE_OF_A_KIND, [rank] + kickers)
        
        # 8. 两对
        pairs = [r for r, c in rank_counts.items() if c == 2]
        if len(pairs) >= 2:
            high_pairs = sorted(pairs, reverse=True)[:2]
            kicker = max([r for r in ranks if r not in high_pairs])
            return (HandRank.TWO_PAIR, high_pairs + [kicker])
        
        # 9. 一对
        for rank, count in rank_counts.most_common(4):
            if count == 2:
                kickers = sorted([r for r in ranks if r != rank], reverse=True)[:3]
                return (HandRank.ONE_PAIR, [rank] + kickers)
        
        # 10. 高牌
        high_cards = sorted(ranks, reverse=True)[:5]
        return (HandRank.HIGH_CARD, high_cards)
    
    def _check_straight(self, ranks: List[int]) -> Optional[int]:
        """检查是否有顺子，返回顺子最高牌值"""
        unique_ranks = sorted(set(ranks), reverse=True)
        
        for i in range(len(unique_ranks) - 4):
            if unique_ranks[i] - unique_ranks[i + 4] == 4:
                return unique_ranks[i]
            # 检查A2345顺子
            if unique_ranks[i] == 14 and unique_ranks[i+4] == 1:
                return 5  # 5高顺子
        
        return None
    
    def compare_to(self, other: 'PokerHand') -> int:
        """比较两手牌大小
        Returns:
            1: self更大, -1: other更大, 0: 平手
        """
        if self.best_hand[0].value < other.best_hand[0].value:
            return 1  # 值越小等级越高
        elif self.best_hand[0].value > other.best_hand[0].value:
            return -1
        else:
            # 牌型相同，比较辅助值
            for self_val, other_val in zip(self.best_hand[1], other.best_hand[1]):
                if self_val > other_val:
                    return 1
                elif self_val < other_val:
                    return -1
            return 0
```

### 6.4 牌型概率计算

```python
class HandProbability:
    """手牌概率计算"""
    
    @staticmethod
    def get_hand_probabilities(num_players: int = 2) -> dict:
        """获取各牌型概率
        Args:
            num_players: 玩家数量
        """
        # 概率表（基于7张牌的最佳5张组合）
        probabilities = {
            'Royal Flush': 0.00001539,
            'Straight Flush': 0.0001390,
            'Four of a Kind': 0.002401,
            'Full House': 0.0014407,
            'Flush': 0.0019654,
            'Straight': 0.0039246,
            'Three of a Kind': 0.0211285,
            'Two Pair': 0.0475390,
            'One Pair': 0.422569,
            'High Card': 0.501177
        }
        
        # 考虑玩家数量调整
        # 更多玩家 = 更多竞争 = 更高概率出现好牌
        adjustment = 1 + (num_players - 1) * 0.01
        
        return {hand: prob * adjustment for hand, prob in probabilities.items()}
    
    @staticmethod
    def calculate_outs(hand: PokerHand, community_cards: List[Tuple]) -> dict:
        """计算outs（改进手牌的牌）
        Args:
            hand: 当前手牌
            community_cards: 公共牌
        
        Returns:
            {目标牌型: outs数量}
        """
        # 这是一个简化版本
        # 完整实现需要考虑具体手牌状态
        return {}
```

---

## 7. 胜负判定

### 7.1 摊牌流程

```python
class Showdown:
    """摊牌管理器"""
    
    def __init__(self, players: list, community_cards: list):
        """初始化摊牌
        Args:
            players: 仍在游戏中的玩家列表
            community_cards: 公共牌
        """
        self.players = players
        self.community_cards = community_cards
    
    def determine_winner(self) -> list:
        """确定获胜玩家
        Returns:
            [获胜玩家ID列表]
        """
        # 评估所有玩家的手牌
        player_hands = []
        for player in self.players:
            if player.is_active and not player.has_folded:
                hand = PokerHand(player.hole_cards, self.community_cards)
                player_hands.append({
                    'player': player,
                    'hand': hand,
                    'rank': hand.best_hand[0],
                    'values': hand.best_hand[1]
                })
        
        if not player_hands:
            return []  # 没有人可以竞争底池
        
        # 排序找最大
        player_hands.sort(key=lambda x: (x['rank'].value, x['values']), reverse=True)
        
        # 找出所有最大者
        max_hand = player_hands[0]
        winners = [p['player'].id for p in player_hands 
                  if (p['rank'].value == max_hand['rank'].value and 
                      p['values'] == max_hand['values'])]
        
        return winners
    
    def get_hand_description(self, player_id: int) -> str:
        """获取玩家手牌描述"""
        player = next((p for p in self.players if p.id == player_id), None)
        if not player:
            return "未知玩家"
        
        hand = PokerHand(player.hole_cards, self.community_cards)
        rank_name = self._get_rank_name(hand.best_hand[0])
        details = self._get_hand_details(hand)
        
        return f"{rank_name}: {details}"
    
    def _get_rank_name(self, rank: HandRank) -> str:
        """获取牌型名称"""
        names = {
            HandRank.ROYAL_FLUSH: "皇家同花顺",
            HandRank.STRAIGHT_FLUSH: "同花顺",
            HandRank.FOUR_OF_A_KIND: "四条",
            HandRank.FULL_HOUSE: "葫芦",
            HandRank.FLUSH: "同花",
            HandRank.STRAIGHT: "顺子",
            HandRank.THREE_OF_A_KIND: "三条",
            HandRank.TWO_PAIR: "两对",
            HandRank.ONE_PAIR: "一对",
            HandRank.HIGH_CARD: "高牌"
        }
        return names.get(rank, "未知")
    
    def _get_hand_details(self, hand: PokerHand) -> str:
        """获取手牌详细信息"""
        rank, values = hand.best_hand
        
        if rank == HandRank.ROYAL_FLUSH:
            return f"{self._get_suit_str(hand)}皇家同花顺"
        elif rank == HandRank.STRAIGHT_FLUSH:
            return f"{values[0]}高同花顺"
        elif rank == HandRank.FOUR_OF_A_KIND:
            return f"{values[0]}踢脚四条"
        elif rank == HandRank.FULL_HOUSE:
            return f"{values[0]}带{values[1]}葫芦"
        elif rank == HandRank.FLUSH:
            return f"{self._get_suit_str(hand)}同花，{values[0]}高"
        elif rank == HandRank.STRAIGHT:
            return f"{values[0]}高顺子"
        elif rank == HandRank.THREE_OF_A_KIND:
            return f"{values[0]}踢脚三条"
        elif rank == HandRank.TWO_PAIR:
            return f"{values[0]}和{values[1]}两对"
        elif rank == HandRank.ONE_PAIR:
            return f"{values[0]}对子"
        else:
            return f"A高" if 14 in values else f"{values[0]}高"
    
    def _get_suit_str(self, hand: PokerHand) -> str:
        """获取同花色"""
        for suit, cards in Counter([c[1] for c in hand.all_cards]).items():
            if cards >= 5:
                return suit
        return ""
```

### 7.2 底池分配

```python
class PotDistributor:
    """底池分配器"""
    
    def __init__(self, main_pot: int, side_pots: list):
        """初始化底池分配器
        Args:
            main_pot: 主池金额
            side_pots: 边池列表 [{amount, eligible_players}]
        """
        self.main_pot = main_pot
        self.side_pots = side_pots
    
    def distribute(self, winners: dict) -> dict:
        """分配底池
        Args:
            winners: {玩家ID: [竞争的池列表]}
        
        Returns:
            {玩家ID: 获得金额}
        """
        distributions = {}
        
        # 分配每个边池
        all_pots = [{'type': 'main', 'amount': self.main_pot, 'eligible': list(winners.keys())}]
        all_pots.extend(self.side_pots)
        
        for pot in all_pots:
            pot_winners = [pid for pid, pots in winners.items() 
                          if pot in pots or 'all' in pots]
            
            if not pot_winners:
                continue
            
            share = pot['amount'] // len(pot_winners)
            remainder = pot['amount'] % len(pot_winners)
            
            for pid in pot_winners:
                distributions[pid] = distributions.get(pid, 0) + share
            
            # 余数给第一位（或其他规则）
            if remainder > 0:
                distributions[pot_winners[0]] += remainder
        
        return distributions
```

### 7.3 特殊胜负情况

```python
class SpecialCases:
    """特殊胜负情况处理"""
    
    @staticmethod
    def handle_all_in_situation(players: list, pot: int) -> dict:
        """处理全下情况"""
        # 详见边池机制
        pass
    
    @staticmethod
    def handle_mucked_hand(player: Player) -> bool:
        """处理误弃牌（muck）"""
        # 某些情况下允许撤回弃牌
        # 需要庄家或规则判定
        return False
    
    @staticmethod
    def check_for_foul(player: Player) -> bool:
        """检查是否有违规手牌"""
        # 检查是否使用标记的牌等
        return False
```

---

## 8. 特殊规则

### 8.1 时限规则

```python
class TimeLimit:
    """时限管理器"""
    
    def __init__(self):
        self.action_timeouts = {
            ActionType.FOLD: 15,       # 弃牌
            ActionType.CHECK: 20,      # 看牌
            ActionType.CALL: 20,       # 跟注
            ActionType.RAISE: 60,      # 加注
            ActionType.ALL_IN: 30,     # 全下
        }
        self.default_timeout = 30
        self.warning_time = 10  # 警告倒计时
    
    def get_timeout(self, action_type: ActionType) -> int:
        """获取行动时限"""
        return self.action_timeouts.get(action_type, self.default_timeout)
```

### 8.2 离座规则

```python
class LeaveSeatRules:
    """离座规则"""
    
    def __init__(self):
        self.max_leave_time = 60  # 最大离座时间（秒）
        self.auto_fold_time = 120  # 超时自动弃牌时间
    
    def handle_player_leave(self, player: Player, game: Game) -> None:
        """处理玩家离座"""
        if player.has_acted_current_round:
            # 已行动，暂时离座
            game.inactive_players.add(player.id)
        else:
            # 未行动，视为弃牌
            player.fold()
    
    def auto_fold_expired(self, player: Player, game: Game) -> None:
        """超时自动弃牌"""
        if player.id in game.inactive_players:
            player.fold()
            game.inactive_players.discard(player.id)
```

### 8.3 断线重连

```python
class ReconnectionManager:
    """断线重连管理器"""
    
    def __init__(self):
        self.reconnect_timeout = 300  # 5分钟重连窗口
        self.hand_history = []        # 保留手牌历史
    
    def handle_disconnect(self, player: Player, game: Game) -> None:
        """处理玩家断线"""
        player.is_connected = False
        # 记录断线时间
        player.disconnect_time = datetime.now()
        # 通知其他玩家
        game.broadcast(f"玩家 {player.name} 已断线")
    
    def attempt_reconnect(self, player: Player, game: Game) -> bool:
        """尝试重连"""
        if datetime.now() - player.disconnect_time < timedelta(seconds=self.reconnect_timeout):
            player.is_connected = True
            return True
        return False
    
    def expire_connection(self, player: Player, game: Game) -> None:
        """连接过期处理"""
        if not player.is_all_in:
            player.fold()
        # 保留筹码
        game.inactive_players.discard(player.id)
```

### 8.4 游戏规则变体

#### 8.4.1 短牌德州扑克（Short Deck Hold'em）

```
规则差异：
- 使用36张牌（去除2-5）
- A仍可作高也可作低
- 同花大于葫芦
- 顺子概率更高
```

#### 8.4.2 无限注 vs 限注

```
限注（Limit）：
- 固定下注额度
- 每轮最多4次加注
- 策略更可预测

无限注（No-Limit）：
- 可下注任意金额
- 随时可以全下
- 波动更大
```

#### 8.4.3 底池限注（Pot-Limit）

```
最大下注 = 当前底池 + 跟注额 + 当前最高注
```

---

## 9. 游戏状态机

### 9.1 完整状态机定义

```python
from enum import Enum, auto
from typing import Callable

class GameState(Enum):
    """游戏状态"""
    IDLE = auto()              # 空闲（等待玩家）
    ANTE = auto()              # 前注阶段
    BLINDS = auto()            # 盲注阶段
    PRE_FLOP = auto()          # 翻牌前
    PRE_FLOP_BETTING = auto()  # 翻牌前下注中
    FLOP = auto()              # 翻牌
    FLOP_BETTING = auto()      # 翻牌圈下注
    TURN = auto()              # 转牌
    TURN_BETTING = auto()      # 转牌圈下注
    RIVER = auto()             # 河牌
    RIVER_BETTING = auto()     # 河牌圈下注
    SHOWDOWN = auto()          # 摊牌
    HAND_END = auto()          # 本局结束
    TOURNAMENT_END = auto()    # 锦标赛结束

class GameEvent(Enum):
    """游戏事件"""
    PLAYER_JOIN = auto()
    PLAYER_LEAVE = auto()
    PLAYER_ACTION = auto()
    ROUND_START = auto()
    ROUND_END = auto()
    TIMEOUT = auto()
```

### 9.2 状态转换图

```
┌─────────────────────────────────────────────────────────────────┐
│                    德州扑克状态机                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   [IDLE] ──玩家入座──> [ANTE] ──下前注──> [BLINDS]              │
│      ^              │         │              │                  │
│      │              │         │              │                  │
│      │              │         └──────────────┘                  │
│      │              │                                              │
│      │              └────<───── 玩家不足 ───<───────              │
│      │                                                        │
│      │  [BLINDS] ──下盲注──> [PRE_FLOP]                         │
│      │         │              │                                  │
│      │         │              ▼                                  │
│      │         │    [PRE_FLOP_BETTING] ──下注结束──> [FLOP]      │
│      │         │              │                                  │
│      │         └────<──── 玩家不足 ────<───────────              │
│      │                                                        │
│      │  [FLOP] ─发三张牌─> [FLOP_BETTING] ─下注结束─> [TURN]     │
│      │                      │                                    │
│      │         ┌────────────┘                                    │
│      │         │                                                 │
│      │         └────<───── 玩家不足 ────<───────────              │
│      │                                                        │
│      │  [TURN] ─发一张牌─> [TURN_BETTING] ─下注结束─> [RIVER]    │
│      │                      │                                    │
│      │         ┌────────────┘                                    │
│      │         │                                                 │
│      │         └────<───── 玩家不足 ────<───────────              │
│      │                                                        │
│      │  [RIVER] ─发一张牌─> [RIVER_BETTING] ─下注结束─> [SHOWDOWN]
│      │                                                        │
│      ▼                                                        │
│   [SHOWDOWN] ──摊牌──> [HAND_END]                               │
│      │                    │                                      │
│      │                    ▼                                      │
│      └─────── 重置 ─────> [IDLE]                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 9.3 状态机实现

```python
class GameStateMachine:
    """游戏状态机"""
    
    def __init__(self):
        self.state = GameState.IDLE
        self.handlers = {}
        self.enter_actions = {}
        self.exit_actions = {}
        
        # 注册状态转换
        self._register_transitions()
    
    def _register_transitions(self) -> None:
        """注册状态转换"""
        
        # IDLE状态
        self.add_transition(GameState.IDLE, GameEvent.PLAYER_JOIN, 
                           GameState.ANTE, self._on_join)
        
        # ANTE状态
        self.add_transition(GameState.ANTE, GameEvent.ROUND_START,
                           GameState.BLINDS, self._on_ante_complete)
        
        # BLINDS状态
        self.add_transition(GameState.BLINDS, GameEvent.ROUND_START,
                           GameState.PRE_FLOP, self._on_blinds_complete)
        
        # PRE_FLOP到BETTING
        self.add_transition(GameState.PRE_FLOP, GameEvent.ROUND_START,
                           GameState.PRE_FLOP_BETTING, self._on_deal_hole_cards)
        self.add_transition(GameState.PRE_FLOP_BETTING, GameEvent.ROUND_END,
                           GameState.FLOP, self._on_preflop_end)
        
        # FLOP到BETTING
        self.add_transition(GameState.FLOP, GameEvent.ROUND_START,
                           GameState.FLOP_BETTING, self._on_deal_flop)
        self.add_transition(GameState.FLOP_BETTING, GameEvent.ROUND_END,
                           GameState.TURN, self._on_flop_end)
        
        # TURN到BETTING
        self.add_transition(GameState.TURN, GameEvent.ROUND_START,
                           GameState.TURN_BETTING, self._on_deal_turn)
        self.add_transition(GameState.TURN_BETTING, GameEvent.ROUND_END,
                           GameState.RIVER, self._on_turn_end)
        
        # RIVER到BETTING
        self.add_transition(GameState.RIVER, GameEvent.ROUND_START,
                           GameState.RIVER_BETTING, self._on_deal_river)
        self.add_transition(GameState.RIVER_BETTING, GameEvent.ROUND_END,
                           GameState.SHOWDOWN, self._on_river_end)
        
        # SHOWDOWN
        self.add_transition(GameState.SHOWDOWN, GameEvent.ROUND_END,
                           GameState.HAND_END, self._on_showdown)
        
        # 重置
        self.add_transition(GameState.HAND_END, GameEvent.ROUND_END,
                           GameState.IDLE, self._reset_game)
    
    def add_transition(self, from_state: GameState, event: GameEvent,
                       to_state: GameState, action: Callable) -> None:
        """添加状态转换"""
        key = (from_state, event)
        self.handlers[key] = (to_state, action)
    
    def process_event(self, event: GameEvent) -> bool:
        """处理事件"""
        key = (self.state, event)
        
        if key in self.handlers:
            to_state, action = self.handlers[key]
            
            # 执行退出动作
            if self.state in self.exit_actions:
                self.exit_actions[self.state]()
            
            # 状态转换
            self.state = to_state
            
            # 执行进入动作
            if self.state in self.enter_actions:
                self.enter_actions[self.state]()
            
            # 执行转换动作
            action()
            
            return True
        
        return False
    
    # 状态动作方法
    def _on_join(self) -> None:
        pass
    
    def _on_ante_complete(self) -> None:
        self.game.collect_antes()
    
    def _on_blinds_complete(self) -> None:
        self.game.collect_blinds()
    
    def _on_deal_hole_cards(self) -> None:
        self.game.dealer.deal_hole_cards(self.game.players)
    
    def _on_preflop_end(self) -> None:
        pass
    
    def _on_deal_flop(self) -> None:
        self.game.dealer.deal_flop()
    
    def _on_flop_end(self) -> None:
        pass
    
    def _on_deal_turn(self) -> None:
        self.game.dealer.deal_turn()
    
    def _on_turn_end(self) -> None:
        pass
    
    def _on_deal_river(self) -> None:
        self.game.dealer.deal_river()
    
    def _on_river_end(self) -> None:
        pass
    
    def _on_showdown(self) -> None:
        winners = self.game.determine_winners()
        self.game.award_pot(winners)
    
    def _reset_game(self) -> None:
        self.game.prepare_new_hand()
```

---

## 10. 数据结构设计

### 10.1 核心类图

```
┌─────────────────────────────────────────────────────────────────┐
│                       核心类关系图                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────┐                                                │
│  │   Game      │                                                 │
│  ├─────────────┤                                                 │
│  │ - players   │─────────────────────────────────┐              │
│  │ - dealer    │                                 │              │
│  │ - pot       │                                 │              │
│  │ - state     │                                 │              │
│  └─────────────┘                                 │              │
│       │                                          │              │
│       │ contains                                 │              │
│       ▼                                          │              │
│  ┌─────────────┐    deals    ┌─────────────┐   │              │
│  │   Dealer    │────────────>│ CardDeck    │   │              │
│  ├─────────────┤             ├─────────────┤   │              │
│  │ - community │             │ - cards     │   │              │
│  │ - burned    │             └─────────────┘   │              │
│  └─────────────┘                               │              │
│                                               │              │
│  ┌─────────────┐          has          ┌──────▼──────┐        │
│  │   Player   │───────────────────────│ PokerHand   │        │
│  ├─────────────┤                      ├─────────────┤        │
│  │ - id        │                      │ - rank      │        │
│  │ - name      │                      │ - values    │        │
│  │ - chips     │                      └─────────────┘        │
│  │ - hole_cards│                                              │
│  └─────────────┘                                              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 10.2 详细数据结构

#### 10.2.1 玩家数据结构

```python
@dataclass
class Player:
    """玩家数据类"""
    id: int
    name: str
    chips: int = 1000
    position: int = 0  # 相对于庄家的位置
    
    # 状态
    is_active: bool = True
    has_folded: bool = False
    is_all_in: bool = False
    has_acted: bool = False
    is_connected: bool = True
    
    # 牌
    hole_cards: List[Tuple] = field(default_factory=list)
    
    # 下注信息
    current_bet: int = 0
    total_bet_this_hand: int = 0
    
    # 行动历史
    action_history: List[ActionType] = field(default_factory=list)
    
    # 统计
    hands_played: int = 0
    hands_won: int = 0
    total_winnings: int = 0
```

#### 10.2.2 游戏配置

```python
@dataclass
class GameConfig:
    """游戏配置"""
    # 基本设置
    min_players: int = 2
    max_players: int = 9
    starting_chips: int = 1000
    
    # 盲注设置
    small_blind: int = 10
    big_blind: int = 20
    blind_increase_rounds: int = 0  # 0表示不增加
    
    # 可选前注
    ante: int = 0
    ante_round: int = 0  # 多少轮后开始前注
    
    # 下注限制
    min_raise: int = None  # None表示2x大盲
    max_raises: int = 4  # 每轮最大加注次数
    
    # 时限
    action_timeout: int = 30
    auto_muck: bool = True  # 摊牌时自动弃掉输牌
    
    # 规则变体
    game_type: str = "no_limit"  # no_limit, limit, pot_limit
    deck_count: int = 1
```

#### 10.2.3 行动数据结构

```python
@dataclass
class PlayerAction:
    """玩家行动"""
    player_id: int
    action_type: ActionType
    amount: int = 0
    timestamp: datetime = field(default_factory=datetime.now)
    is_valid: bool = True
    error_message: str = ""
```

#### 10.2.4 底池数据结构

```python
@dataclass
class Pot:
    """底池"""
    amount: int
    eligible_players: List[int]  # 有资格争夺此底池的玩家ID列表
    side_pot: bool = False
    contributors: Dict[int, int] = field(default_factory=dict)  # 玩家贡献金额
```

### 10.3 数据库模式（如需要持久化）

```sql
-- 玩家表
CREATE TABLE players (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name VARCHAR(50) NOT NULL,
    chips INTEGER DEFAULT 1000,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 游戏表
CREATE TABLE games (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    game_type VARCHAR(20) DEFAULT 'no_limit',
    min_buy_in INTEGER DEFAULT 100,
    max_buy_in INTEGER DEFAULT 10000,
    status VARCHAR(20) DEFAULT 'waiting', -- waiting, active, finished
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 手牌历史
CREATE TABLE hands (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    game_id INTEGER,
    hand_number INTEGER,
    pot_amount INTEGER,
    community_cards TEXT, -- JSON格式
    winners TEXT, -- JSON格式
    played_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (game_id) REFERENCES games(id)
);

-- 玩家手牌
CREATE TABLE player_hands (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    hand_id INTEGER,
    player_id INTEGER,
    hole_cards TEXT, -- JSON格式
    final_hand_rank VARCHAR(20),
    bet_amount INTEGER,
    won_amount INTEGER,
    actions TEXT, -- JSON格式
    FOREIGN KEY (hand_id) REFERENCES hands(id),
    FOREIGN KEY (player_id) REFERENCES players(id)
);
```

---

## 11. API接口设计

### 11.1 WebSocket API

```typescript
// 客户端发送
interface ClientMessage {
  type: 'join' | 'leave' | 'action' | 'chat' | 'sit_out' | 'back';
  payload: any;
}

// 加入游戏
{
  type: 'join',
  payload: {
    gameId: string;
    playerName: string;
    buyIn: number;
  }
}

// 玩家行动
{
  type: 'action',
  payload: {
    action: 'fold' | 'check' | 'call' | 'raise' | 'all_in';
    amount?: number; // raise时需要
  }
}

// 服务器发送
interface ServerMessage {
  type: 'game_state' | 'player_action' | 'chat' | 'error' | 'winner';
  payload: any;
}

// 游戏状态
{
  type: 'game_state',
  payload: {
    gameId: string;
    stage: 'pre_flop' | 'flop' | 'turn' | 'river' | 'showdown';
    pot: number;
    communityCards: Card[];
    players: PlayerState[];
    currentPlayer: number;
    minBet: number;
    maxBet: number;
    dealerButton: number;
  }
}
```

### 11.2 REST API

```python
# 游戏管理
POST   /api/games                    # 创建游戏
GET    /api/games                    # 获取游戏列表
GET    /api/games/{id}               # 获取游戏详情
DELETE /api/games/{id}               # 删除游戏

# 玩家管理
POST   /api/games/{id}/players       # 加入游戏
DELETE /api/games/{id}/players/{playerId}  # 离开游戏
PUT    /api/games/{id}/players/{playerId}/sit_out  # 离座
PUT    /api/games/{id}/players/{playerId}/back     # 返回

# 游戏操作
POST   /api/games/{id}/start        # 开始游戏
POST   /api/games/{id}/action       # 执行行动
POST   /api/games/{id}/fold         # 弃牌（简化）
POST   /api/games/{id}/check        # 看牌（简化）
POST   /api/games/{id}/call         # 跟注（简化）
POST   /api/games/{id}/raise        # 加注
POST   /api/games/{id}/all_in       # 全下

# 信息获取
GET    /api/games/{id}/state        # 获取游戏状态
GET    /api/games/{id}/players     # 获取玩家列表
GET    /api/games/{id}/pot          # 获取底池信息
GET    /api/games/{id}/history      # 获取手牌历史
```

### 11.3 事件通知

```python
# 使用Redis Pub/Sub或WebSocket进行实时通知

# 游戏事件
{
  "event": "game_started",
  "gameId": "xxx",
  "dealerButton": 1,
  "players": [...]
}

{
  "event": "player_acted",
  "playerId": 1,
  "action": "raise",
  "amount": 200,
  "totalBet": 300
}

{
  "event": "cards_dealt",
  "stage": "flop",
  "communityCards": ["Ah", "Kh", "3d"]
}

{
  "event": "pot_won",
  "winners": [1, 3],
  "amount": 1500,
  "handType": "flush"
}
```

---

## 附录

### A. 术语表

| 术语 | 含义 |
|-----|------|
| Action | 玩家可采取的行动 |
| Bankroll | 玩家用于游戏的总资金 |
| Bankroll Management | 资金管理策略 |
| Bet | 下注 |
| Betting Line | 下注线（盲注位置） |
| Blocker | 阻挡牌 |
| Bluff | 诈唬 |
| Board | 公共牌 |
| Button | 庄家位 |
| Buy-in | 买入金额 |
| Call | 跟注 |
| Cap | 限制加注次数 |
| Check | 看牌 |
| Check-raise | 先看牌后加注 |
| Cold Call | 冷跟（未主动下注直接跟注） |
| Draw | 听牌 |
| Early Position | 前位（EP） |
| Expected Value (EV) | 期望值 |
| Fold | 弃牌 |
| Free Card | 免费牌（没人下注时多看一张） |
| Hand | 一手牌 |
| Heads-up | 单挑 |
| Implied Odds | 潜在赔率 |
| In Position (IP) | 有位置优势 |
| Late Position | 后位（LP） |
| Limp | 平跟入池 |
| Middle Position | 中位（MP） |
| Muck | 弃掉输牌 |
| No Limit | 无限注 |
| Odds | 赔率 |
| Offsuit | 不同花 |
| Open | 公开加注 |
| Out | 改进牌型的牌 |
| Out of Position (OOP) | 无位置优势 |
| Overbet | 超池下注 |
| Overpair | 超对（底牌对比子更大） |
| Pot Odds | 底池赔率 |
| Pot Limit | 底池限注 |
| Raise | 加注 |
| Re-raise | 反加注 |
| River | 河牌 |
| RPS | 石头剪刀布（决定庄家） |
| Showdown | 摊牌 |
| Side Pot | 边池 |
| Slow Play | 慢打 |
| Squeeze | 挤压（隔离加注） |
| Stack | 筹码量 |
| Steal | 偷盲 |
| Suited | 同花 |
| Tell | 马脚 |
| Three-bet | 3-bet（反加注） |
| Tight | 紧（只玩强牌） |
| Turn | 转牌 |
| Under the Gun (UTG) | 枪口位 |
| Value Bet | 价值下注 |

### B. 常用公式

```
底池赔率 (Pot Odds) = 跟注金额 / (底池金额 + 跟注金额)

期望值 (EV) = 胜率 × 收益 - 败率 × 损失

出牌概率估算 (4-2法则)：
- 转牌圈：OUTS数量 × 4 = 河牌圈成牌概率(%)
- 河牌圈：OUTS数量 × 2 = 成牌概率(%)

最小加注 = 当前最高注 × 2 - 已下注额
```

### C. 参考资源

- [Wikipedia - Texas Hold'em](https://en.wikipedia.org/wiki/Texas_hold%27em)
- [PokerRules - Official Poker Rules](https://www.pokerrules.com/)
- [CardPlayer - Poker Strategy](https://www.cardplayer.com/)

---

*文档版本：1.0*  
*最后更新：2026年2月*  
*作者：Matrix Agent*